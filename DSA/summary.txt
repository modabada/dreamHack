시작하기전
inverse 함수는 모듈러 역원 값을 구해내는 역함수이다. 라이브러리 문서상으로는 return of inverse u mod v 라고 하는데 이때 mod 가 나머지가 아닌 모듈러 역함수라는 시발
따라서 inverse(a, b) 는 a * x = 1 (mod b) 라는 항등식을 만족하는 x값을 반환하는 함수


또한 inverse(x, n) = y 라면, inverse(y, n) = x 가 성립함
또한 inverse(k, q) 는 k^(-1) * (아무 수식) (mod q) 라고 표현이 가능
때문에 inverse(k, q) * (아무수식) == k^(-1) * (아무수식) % q 가 성립
마지막으로 inverse(k, q) * (아무수식) % q 역시 모듈러 연산의 성질에 의해 동일한 값이 나옴
- generated by chat GPT
    inverse(k, q) * (아무수식) % q 표현은 inverse(k, q)와 (아무수식)을 곱한 후에 q로 나눈 나머지를 계산하는 것을 의미합니다. 이는 모듈러 연산의 성질에 의해 원하는 결과를 얻을 수 있습니다. 따라서, inverse(k, q) * (아무수식) % q 역시 k^(-1) * (아무수식) % q와 동일한 값을 나타내며, 같은 계산 결과를 얻을 수 있습니다.


DSA 에서는 sign 을 할 때 난수인 x 값을 결정하는데, 해당 시스템은 초기화시 x값을 결정하고 이후에 x값과 k = inverse(x, q) 를 재사용하는것이 주 취약점

s1 = inverse(k, q) * (sha1(m1) + x * r) % q
s2 = inverse(k, q) * (sha1(m2) + x * r) % q

s1 - s2 = invrese(k, q) * (sha1(m1) + x * r - sha1(m2) - x * r) % q
s1 - s2 = inverse(k, q) * (sha1(m1) - sha1(m2))

양변에 inverse(k, q)의 역원을 곱하면
inverse(k, q) * (s1 - s2) % q = inverse(k, q) * inverse(inverse(k, q), q) * sha1(m1) - sha1(m2) % q
inverse(k, q) * (s1 - s2) % q= sha1(m1) - sha1(m2)
※ 우항이 역원 * 역원의 역원 임으로 서로 상쇄됨

양변에 (s1 - s2) 의 역원을 곱하면
((inverse(k, q) * (s1 - s2)) % q) * inverse(s1 - s2, q) = (sha1(m1) - sha1(m2)) * inverse(s1 - s2, q)
((inverse(k, q) * (s1 - s2)) % q) * inverse(s1 - s2, q) = sha1(m1) - sha1(m2)
※ 좌항에 있는 (s1 - s2) 와 우항에 새로 곱한 inverse(s1 - s2, q) 가 서로 상쇄됨

따라서 
inverse(x, q) = k
((inverse(k, q) * (s1 - s2)) % q) * inverse(s1 - s2, q) = sha1(m1) - sha1(m2)
((k * (s1 - s2)) % q) * inverse(s1 - s2, q) = sha1(m1) - sha1(m2)
k = ((sha1(m1) - sha1(m2)) * inverse(s1 - s2, q)) % q
그리고 x = inverse(k, q)

비밀지수 x값을 알아내면, token 을 m 으로 삼아 직접 sign 하고(서버에서는 받아주지 않기 때문에)
그리고 s = sig(token) 을 구해 알아낸 m, r, s 를 바탕으로 서버에 verify 요청을 보낸다